<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Аватар</title>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/4.5.0/fabric.min.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/interactjs@1.10.11/dist/interact.min.js"></script>
	</head>

	<body>
		<canvas id="canvas" width="640" height="640"></canvas>
		<input type="file" id="imageInput" accept="image/*" />
		<button id="downloadButton">Скачать изображение</button>
		<style>
			body {
				display: flex;
				flex-direction: column;
				align-items: center;
				justify-content: center;
				height: 100vh;
				margin: 0;
			}

			#canvas {
				border: 1px solid #ccc;
				border-radius: 50%;
				width: 640px;
				height: 640px;
				margin-bottom: 20px; /* Пример: добавьте отступ после холста */
			}

			#imageInput,
			#downloadButton {
				margin-bottom: 20px; /* Пример: добавьте отступ после элементов input и button */
			}
		</style>

		<script>
			document
				.getElementById('imageInput')
				.addEventListener('change', handleImage)

			function handleImage(e) {
				const canvas = new fabric.Canvas('canvas', {
					width: 640,
					height: 640,
					selection: false,
				})

				const reader = new FileReader()

				reader.onload = function (event) {
					const img = new Image()
					img.onload = function () {
						const fabricImg = new fabric.Image(img, {
							width: img.width,
							height: img.height,
							left: (canvas.width - img.width) / 2,
							top: (canvas.height - img.height) / 2,
							selectable: true,
						})

						fabricImg.set({
							class: 'rounded-image',
							borderColor: '#ccc',
							cornerColor: '#ccc',
							cornerSize: 10,
							transparentCorners: false,
						})

						// Загрузите изображение рамки
						fabric.Image.fromURL('1.png', function (fabricFrame) {
							fabricFrame.set({
								width: canvas.width,
								height: canvas.height,
								selectable: false,
								lockMovementX: true,
								lockMovementY: true,
								lockScaling: true,
							})

							// Применить круглую форму к фрейму
							fabricFrame.set({
								clipTo: function (ctx) {
									ctx.arc(
										canvas.width / 2,
										canvas.height / 2,
										canvas.width / 2,
										0,
										2 * Math.PI
									)
								},
							})

							// Создать группу из изображения рамки и обработанного изображения
							const group = new fabric.Group([fabricFrame, fabricImg], {
								selectable: true,
							})

							// Добавить группу на холст
							canvas.add(group)

							// Обновить холст
							canvas.renderAll()
						})
					}
					img.src = event.target.result
				}

				reader.readAsDataURL(e.target.files[0])
			}

			document
				.getElementById('downloadButton')
				.addEventListener('click', function () {
					const canvas = document.getElementById('canvas')
					const imageDataUrl = getTrimmedCanvasDataURL(canvas)
					const downloadLink = document.createElement('a')
					downloadLink.href = imageDataUrl
					downloadLink.download = 'avatar.png'
					document.body.appendChild(downloadLink)
					downloadLink.click()
					document.body.removeChild(downloadLink)
				})

			function getTrimmedCanvasDataURL(canvas) {
				const diameter = 640
				const context = canvas.getContext('2d')
				const imageData = context.getImageData(
					0,
					0,
					canvas.width,
					canvas.height
				)

				// Находим границы обрезанной области
				let minX = canvas.width
				let minY = canvas.height
				let maxX = 0
				let maxY = 0

				for (let y = 0; y < canvas.height; y++) {
					for (let x = 0; x < canvas.width; x++) {
						const alpha = imageData.data[(y * canvas.width + x) * 4 + 3]
						if (alpha > 0) {
							minX = Math.min(minX, x)
							minY = Math.min(minY, y)
							maxX = Math.max(maxX, x)
							maxY = Math.max(maxY, y)
						}
					}
				}

				// Создаем новый canvas с обрезанной и измененной областью
				const trimmedCanvas = document.createElement('canvas')
				trimmedCanvas.width = diameter
				trimmedCanvas.height = diameter
				const trimmedContext = trimmedCanvas.getContext('2d')

				// Рисуем обрезанную область как круг
				trimmedContext.beginPath()
				trimmedContext.arc(
					diameter / 2,
					diameter / 2,
					diameter / 2,
					0,
					2 * Math.PI
				)
				trimmedContext.closePath()
				trimmedContext.clip()
				trimmedContext.drawImage(
					canvas,
					minX,
					minY,
					maxX - minX + 1,
					maxY - minY + 1,
					0,
					0,
					diameter,
					diameter
				)

				// Наложим изображение 1.png поверх обрезанной области
				const frameImage = new Image()
				frameImage.src = '1.png' // Укажите путь к изображению рамки
				trimmedContext.drawImage(frameImage, 0, 0, diameter, diameter)

				return trimmedCanvas.toDataURL('image/png')
			}
		</script>
	</body>
</html>
